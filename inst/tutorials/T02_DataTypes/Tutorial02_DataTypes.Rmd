---
title: "Data Types"
author:
  name: Pete E. Pascuzzi
  affiliation: Purdue University
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = FALSE)
```

## Introduction

To work with any kind of data with **R**, it needs to be stored in your **working environment** (memory) as an **object**.  There are many types of **objects** in **R** ranging from simple **integer vectors** to complex **ExpressionSets** that store and describe complex biological data.  Regardless of complexity, **objects** are usually built from simpler **objects**.    

The simplest **class** of **R object** is the **vector** which has four common **types**: **integer**, **numeric**, **character** and **logical**.  The type of underlying data determines the **type** of the **vector**.  **Vectors** can store as few as one value and up to millions of values (the limit is determined by you computer).  

## Learning Objectives

* Identify the common data types in **R**.  
* Explain the difference between **numeric** and **integer** data types.  
* Determine the length of a **character vector** and the number of characters in a character string.
* Use relational operators to create **logical** data.
* Create **vectors** with functions such as `c`, `rep` and `seq`.

## Integer Type  

**Integers** are whole numbers--no decimel places allowed!  If you have data that meets this condition, then you should store it as an **integer**.  By default, **R** will not store a whole number as an **integer**.  You must follow any whole number that you want to store as an **integer** with a capital `L`.  Why `L`?  There are historical reasons in computer science for this, but the exact reason seems to be lost.  

Look at the output from the following code chunks.  We use `class` to show the class of our **objects**.

First, the **numeric vector**.

```{r ex1, exercise=TRUE, exercise.startover=TRUE}
my_five <- 5
class(my_five)
```

Now, the **integer vector**.  

```{r ex2, exercise=TRUE, exercise.startover=TRUE}
my_int <- 5L
class(my_int)
```

In most respects, `my_five` and `my_int` will behave similarly.  We can use the **relational operator** for equality, `==`, to determine if the values in `my_five` and `my_int` are the same.  

```{r ex3-setup, include=FALSE}
my_five <- 5
my_int <- 5L
```

```{r ex3, exercise=TRUE, exercise.startover=TRUE, exercise.setup="ex3-setup"}
my_five == my_int
```

They are.  But, are the **R objects**, `my_five` and `my_int` the same?  We can use the **function** `identical` to test this.  

```{r ex4, exercise=TRUE, exercise.startover=TRUE, exercise.setup="ex3-setup"}
identical(my_five, my_int)
```

They are not.  Remember, the values in two **objects** may be the same, but the **objects** themselves may be different.  

## Numeric Type

If your numbers have decimal points, then you need to store them as **numeric vectors**.  This class is sometimes referred to as **double** or **float**.  This is computer science terminology that you do not need to worry about.  What you do need to know is that decimal numbers can create unpredictable results if you do not use them carefully.  More on this later.  

```{r ex5, exercise=TRUE, exercise.startover=TRUE}
my_numeric <- 5.5
class(my_numeric)
```

You can perform arithmetic operations that use a mixture of **numeric** and **integer** **vectors**.  However, the result will be a **numeric vector**.  

```{r ex6-setup, include=FALSE}
my_numeric <- 5.5
my_int <- 5L
```

```{r ex6, exercise=TRUE, exercise.startover=TRUE, exercise.setup="ex6-setup"}
my_sum <- my_numeric + my_int
class(my_sum)
```

## Character Type

You have already used **character vectors** several times.  The **character** patterns that you used with `help.search` in the first tutorial were **character vectors**.  This is an extremely important data type, but it is often fraught with inconsistencies because this data is almost always entered by humans, whereas numeric or integer data is often generated by instruments (which can also have glitches that create inconsistencies).   

There are two common points of confusion with **character vectors**.  The first concerns the length of the **character vectors** as oppossed to the length of an individual **character** pattern or string.  By pattern or string, we mean the group of **characters** that fall inside the pair of parentheses that are required syntax for **character** strings.  

```{r ex7, exercise=TRUE, exercise.startover=TRUE}
my_string <- "my string"
my_string
```

The **object**, `my_string` is a **character vector** that contains a single value or element.  Therefore, it has a length of one.  However, the **character** string, `my string`, obviously has more than one character.  

Here is the `length` or number of elements of the **vector**.

```{r ex8-setup, include=FALSE}
my_string <- "my string"
```

```{r ex8, exercise=TRUE, exercise.startover=TRUE, exercise.setup="ex8-setup"}
length(my_string)
```

Here is the number of characters in each element of the **character vector** using the function, `nchar`. 

```{r ex9, exercise=TRUE, exercise.startover=TRUE, exercise.setup="ex8-setup"}
nchar(my_string)
```

We can make a **character vector** of length nine with the function, `rep`.

```{r ex10, exercise=TRUE, exercise.startover=TRUE, exercise.setup="ex8-setup"}
nine_string <- rep(my_string, 9)
nine_string
```

We now have a **character vector** with nine values, each of which is `my_string`.  So, in total, there are 81 characters in the **character vector**, but they are grouped into nine elements.  

```{r ex11a-setup, include=FALSE}
my_string <- "my string"
nine_string <- rep(my_string, 9)
```

```{r ex11a, exercise=TRUE, exercise.startover=TRUE, exercise.setup="ex11a-setup"}
length(nine_string)
```

You can determine the number of characters in each element of `nine_string` with `nchar`.  This works because the function `nchar` is **vectorized**.  It will perform calculations on every value in a **vector**.  This will be covered in more detail later in the tutorial.  

```{r ex11b-setup, include=FALSE}
my_string <- "my string"
nine_string <- rep(my_string, 9)
```

```{r ex11b, exercise=TRUE, exercise.startover=TRUE, exercise.setup="ex11b-setup"}
nchar(nine_string)
```

There are many ways to make **vectors** in **R**.  We will work with more of them later.

The second common source of confusion with **character vectors** arises because some **R functions** will convert **characters** to **factors**.  A **factor** is a different R data type that looks like a **character** but can have very different behavior.  **Factors** are very important, but they will be covered in a later tutorial.  

## Logical Types

All of you are familiar with Boolean expressions, even though you might not be aware of it.  For example, you might have a price limit of twenty dollars when ordering in a restaurant.  When browsing down the menu, you evaluate each item, "Is this twenty dollars or less?"  The result is either, yes (`TRUE`) or no (`FALSE`).  This simplifies your choices, and then you can evaluate by other criteria (which may also be phrased as Boolean expressions).  

Boolean expressions are composed of **relational operators** such as **equals**, **less than** and **greater than**.  See the help page on **Comparison**.  

```{r ex12, exercise=TRUE, exercise.startover=TRUE}
help(`Comparison`)
```

There are three possible values for **logical** data:  `TRUE`, `FALSE` or `NA`.  The last stands for "Not Available".  This is a special data value that can occur with any data type.  We will deal with `NA` more later.  It is mentioned here so that you don't have the misconception that all **logicals** are either `TRUE` or `FALSE`.  

The chunk below determines if 1 is equal to 1.  

```{r ex13, exercise=TRUE, exercise.startover=TRUE}
1 == 1
```

This chunk determines if 1 is greater than 1.  

```{r ex14, exercise=TRUE, exercise.startover=TRUE}
1 > 1
```

You need to be careful with **logical** data because you can get surprising results.  

For example, `TRUE` is equivalent to one.  

```{r ex15, exercise=TRUE, exercise.startover=TRUE}
TRUE == 1
```

And, `FALSE` is equivalent to zero.  

```{r ex16, exercise=TRUE, exercise.startover=TRUE}
FALSE == 0
```

You can even add **logical** values.  In the chunk below, the **combine** function, `c`, is used to create a short **logical vector** with three values.  

```{r ex17, exercise=TRUE, exercise.startover=TRUE}
sum(c(TRUE, TRUE, FALSE))
```

Here is an even more surprising result when we use `as.logical` to transform an **integer vector** to a **logical vector**.  

```{r ex18, exercise=TRUE, exercise.startover=TRUE}
as.logical(c(10, 1, 0, -1, -10))
```

Note that any non-zero value is converted to `TRUE`.  These tricks with **logical** values can be useful in certain circumstances. 

You can modify and combine your relational expression with the **logical operators** such as **and**, `&`, and **or**, `|`.  

```{r ex19, exercise=TRUE, exercise.startover=TRUE}
help(`&`)
```

Combining **relational** and **logical operators** provides a powerful way to filter or subset your data (more in later tutorials).  

```{r ex20, exercise=TRUE, exercise.startover=TRUE}
c(1, 10, 100) > 1 & c(1, 10, 100) < 100
```

The above expression may seem rather useless, but similar expressions can be used to extract data from **vectors** and **R objects**.  

When manipulating data with **R**, it may be necessary to run an expression or extract data for a relational expression that is not `TRUE`.  The requires the **not** operator, `!`.  This operator simply switches the logical value from `TRUE` to `FALSE` or vice-versa.  

```{r ex21, exercise=TRUE, exercise.startover=TRUE}
!TRUE == FALSE
```

We can add **not** to our previous expression, you need to use parenthesis to group the relational expression.  Now, we select value that are **not** between 1 and 100.  

```{r ex22, exercise=TRUE, exercise.startover=TRUE}
!(c(1, 10, 100) > 1 & c(1, 10, 100) < 100)
```

Here is a table of some useful logical operators.  

|English  |R operator|
|:--------------------|:-----|
|equals     |`==`|
|less than          |`<`|
|greater than       |`>`|
|less than or equal |`<=`|
|greater than or equal |`>=`|
|and                |`&`|
|or                 |`|`|
|not                |`!`|
|matching           |`%in%`|


## Vectors

The previous sections focused on the data type, but in several cases we created **objects** named **vectors**.  **Vectors** store data values in a specific order.  The data values must all be of the same data type.  If you try to combine values of different data types, the result will be a **character vector**.  

```{r ex23a, exercise=TRUE, exercise.startover=TRUE}
my_vector <- c(1, 1.1, "one", TRUE)
my_vector
```

You can tell this is a **character vector** because all of the values are flanked by double quotes, `" "`.  You can also check the **class** of the **object**.  

```{r ex23b-setup, include=FALSE}
my_vector <- c(1, 1.1, "one", TRUE)
```

```{r ex23b, exercise=TRUE, exerise.startover=TRUE, exercise.setup="ex23b-setup"}
class(my_vector)
```

### Combine Function  

One of the most common ways to create **vectors** is with the combine function, `c`.  Combine can be used to create any type of **vector**.  

```{r ex24, exercise=TRUE, exercise.startover=TRUE}
my_integer <- c(1L, 2L, 3L)
class(my_integer)
```

```{r ex25, exercise=TRUE, exercise.startover=TRUE}
my_numeric <- c(1, 2, 3)
class(my_numeric)
```

```{r ex26, exercise=TRUE, exercise.startover=TRUE}
my_character <- c("one", "two", "three")
class(my_character)
```

**Logical vectors** are seldom created in this way.  They are usually created from a relational operation on an existing vector.

```{r ex27-setup, include=FALSE}
my_character <- c("one", "two", "three")
```

```{r ex27, exercise=TRUE, exercise.startover=TRUE, exercise.setup="ex27-setup"}
my_logical <- my_character == "two"
class(my_logical)
```

```{r ex28-setup, include=FALSE}
my_character <- c("one", "two", "three")
my_logical <- my_character == "two"
```

```{r ex28, exercise=TRUE, exercise.startover=TRUE, exercise.setup="ex28-setup"}
my_logical
```

Given that you have to manually type all data values with combine, it is typically used only to create short **vectors**.  

### Rep

The replicate function, `rep`, can be useful to create **vectors** that have a limited number of values that are repeated in a specific order. Do not confuse the functions `rep`, `replicate`, and `repeat`.  They have similar names, but their uses are quite distinct.  

```{r ex29, exercise=TRUE, exercise.startover=TRUE}
my_rep <- rep("red", times=10)
my_rep
```

It is very common to use `rep` and `c` in **nested expressions**.  Combine is used to create a **character vector** that is then repeated a specific number of times.  You can control how the **character vector** is repeated by specifying either `times` or `each`.    

This chunk will repeat the **character vector** the specified number of `times`.  

```{r ex30, exercise=TRUE, exercise.startover=TRUE}
my_times <- rep(c("red", "yellow", "green"), times=2)
my_times
```

This chunk will repeat `each` value in the **character vector** the specified number.

```{r ex31, exercise=TRUE, exercise.startover=TRUE}
my_each <- rep(c("red", "yellow", "green"), each=2)
my_each
```

### Number Sequences

It is often necessary to create specific number sequences when manipulating data.  There are two common ways to do this.  

You can use the **colon operator**, `:`, to create integer sequences incremented by one.  

```{r ex32, exercise=TRUE, exercise.startover=TRUE}
my_sequence <- 1:11
my_sequence
```

You can even create them in reverse order.  

```{r ex33, exercise=TRUE, exercise.startover=TRUE}
my_revseq <- 11:1
my_revseq
```

The sequence function, `seq`, is more flexible because you can specify the start, `from`, and end, `to`, values as well as an incremental value, `by`.  

```{r ex34, exercise=TRUE, exercise.startover=TRUE}
my_sequence <- seq(from=5, to=25, by=5)
my_sequence
```

## Vectorized Operations

One important characteristic of computing with **R** is that many functions are **vectorized**, i.e. they work on every value in a **vector**, essentially simultaneously.  

So, we can add a constant to one of our previous **numeric vectors**, and the constant will be added to every value in the **vector**.  

```{r ex35, exercise=TRUE, exercise.startover=TRUE}
my_sequence <- seq(from=5, to=25, by=5)
my_sequence <- my_sequence + 1
my_sequence
```

The relational expression below is evaluated for every value in `my_each`.  

```{r ex36, exercise=TRUE, exercise.startover=TRUE}
my_each <- rep(c("red", "yellow", "green"), each=2)
my_each == "yellow"
```

In each case, the `length` of the resulting **vector** was the same length as the longest **vector** in the expression.  This brings us to the **Recycling Rule** for **vectors** in **R**.  If you perform an operation on **vectors** of unequal length, the shorter **vector** will be recycled so that the result has the same length as the longer **vector**.  

This is best illustrated by some examples.  

```{r ex37, exercise=TRUE, exercise.startover=TRUE}
vector1 <- seq(from=5, to=25, by=5)
vector2 <- 1:2
vector1 + vector2
```

We have five values in our first **vector**, but only two values in the second.  Therefore, **R** has to recycle the values in the second vector to complete the addition in the first vector.

|Position in vector1|Position in vector2|
|:-----|:-----|
|1|1|
|2|2|
|3|1|
|4|2|
|5|1|

Note that **R** also gave you a warning that your **vector** lengths were not a multiple of each other.  

Here is another example with the **character vector**.  

```{r ex38, exercise=TRUE, exercise.startover=TRUE}
my_each <- rep(c("red", "yellow", "green"), each=2)
my_test <- c("yellow", "red")
my_each == my_test
```

|Value in `my_each`|Value in `my_test`|Result|
|:-----|:-----|:-----|
|"red"|"yellow"|`FALSE`
|"red"|"red"|`TRUE`
|"yellow"|"yellow"|`TRUE`
|"yellow"|"red"|`FALSE`
|"green"|"yellow"|`FALSE`
|"green"|"red"|`FALSE`

Note how the comparison changes as you work down the **vectors**.  You will be reminded of the **Recycling Rule** any time that it is a potential issue for class.  

This completes the lesson on data types.  This knowledge is fundamental to build your prociency with **R**.  The next tutorial will focus more closely on **vectors**.  

## Quiz  

Time for a short quiz.  Use the help menu or try various answers as much as you want.  There is no penalty for multiple attempts.  If you are stuck, click the `Hints` button to get progressive hints.  The last hint is the answer!

### Question 1
#### What are the common data types for **R vectors**? Check all that apply.  

```{r q-1, echo=FALSE}
question("",
  answer("logical", correct=TRUE),
  answer("character", correct=TRUE),
  answer("string"),
  answer("numeric", correct=TRUE),
  answer("factor"),
  answer("integer", correct=TRUE)
)
```

### Question 2
#### Create a **character vector** named `my_data` that contains these values, "blue", "red", "blue", "red", "blue", "red", "blue", "red" and display it.  

```{r q-2, exercise=TRUE, exercise.startover=TRUE}

```

```{r q-2-hint-1}
my_data <- 
```

```{r q-2-hint-2}
my_data <- rep()
```

```{r q-2-hint-3}
my_data <- rep(c(), )
```

```{r q-2-hint-4}
my_data <- rep(c("blue", "red"), )
```

```{r q-2-hint-5}
my_data <- rep(c("blue", "red"), times=)
```

```{r q-2-hint-6}
my_data <- rep(c("blue", "red"), times=4) #Efficient
my_data
```

```{r q-2-hint-7}
my_data <- c("blue", "red", "blue", "red", "blue", "red", "blue", "red") #Also OK
my_data
```

### Question 3  
#### Given this expression, `my_sum <- 21.22 + 2L`, what is the class and/or data type of `my_sum`.  Check all that apply.  

```{r q-3, echo=FALSE}
question("",
  answer("integer"),
  answer("numeric", correct=TRUE),
  answer("vector", correct=TRUE),
  answer("continuous")
)
```

### Question 4  
#### What is the result for this relational expression, `!(1:3 >= c(1, 11))`?


```{r q-4, echo=FALSE}
question("",
  answer("TRUE FALSE TRUE"),
  answer("TRUE FALSE"),
  answer("FALSE TRUE FALSE", correct=TRUE),
  answer("FALSE TRUE")
)
```

### Question 5
#### Write the code that will create a **vector** named `my_seq` that contains the values 100, 80, 60, 40 and 20 **in that order**, and display it. This question is a bit tricky.

```{r q-5, exercise=TRUE, exercise.startover=TRUE}

```

```{r q-5-hint-1}
my_seq <- 
```

```{r q-5-hint-2}
my_seq <- seq()
```

```{r q-5-hint-3}
my_seq <- seq(from=100, )
```

```{r q-5-hint-4}
my_seq <- seq(from=100, to=20, )
```

```{r q-5-hint-5}
my_seq <- seq(from=100, to=20, by= -20)
my_seq
```

## Final Comments  

This is the end of the tutorial.  You now have a basic knowledge of the common **R** data types.  Future tutorials will focus on **vectors** and **tibbles**, table-like **objects** that can store rectangular datasets.  
